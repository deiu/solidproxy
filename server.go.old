package solidproxy

import (
	"log"
	"net/http"
	"net/url"
)

// Server object contains http handler, config object and logger object
type Server struct {
	http.Handler

	Config *ServerConfig
	log    *log.Logger
}

type response struct {
	status  int
	headers http.Header

	argv []interface{}
}

type httpRequest struct {
	*http.Request
	*Server
	AcceptType  string
	ContentType string
}

// NewProxyServer is used to create a new proxy server instance
func NewProxyServer(config *ServerConfig) *Server {
	s := &Server{
		Config: config,
	}
	if len(config.Verbose) > 0 {
		s.log = log.New(os.Stderr, debugPrefix, debugFlags)
	} else {
		s.log = log.New(ioutil.Discard, "", 0)
	}
	s.log.Println("---- starting server ----")
	s.log.Printf("config: %#v\n", s.Config)
	return s
}

// ServeHTTP handles the response
func (s *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	// Setup CORS
	origin := ""
	origins := req.Header["Origin"] // all CORS requests
	if len(origins) > 0 {
		origin = origins[0]
		w.Header().Set("Access-Control-Allow-Origin", origin)
	}
	if len(origin) < 1 {
		w.Header().Set("Access-Control-Allow-Origin", "*")
	}

	// Rewrite URL and serve proxy
	if len(req.FormValue("uri")) > 0 {
		req = s.NewProxyReq(req)
		proxy.ServeHTTP(w, req)
		return
	}

	// Serve content (e.g. the agent's WebID)
	defer func() {
		req.Body.Close()
	}()
	r := s.handle(w, &httpRequest{req, s, "", ""})
	for key := range r.headers {
		w.Header().Set(key, r.headers.Get(key))
	}
	if r.status > 0 {
		w.WriteHeader(r.status)
	}
	if len(r.argv) > 0 {
		fmt.Fprint(w, r.argv...)
	}
}

func (r *response) respond(status int, a ...interface{}) *response {
	r.status = status
	r.argv = a
	return r
}

func (s *Server) handle(w http.ResponseWriter, req *httpRequest) (r *response) {
	r = new(response)
	var err error

	// Try to recover in case of panics
	defer func() {
		if rec := recover(); rec != nil {
			s.debug.Println("\nRecovered from panic: ", rec)
			r.respond(500)
			return
		}
	}()

}
